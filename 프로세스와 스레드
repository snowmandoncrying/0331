프로세스는 실행 중인 하나의 프로그램이다.
하나의 프로그램이 다중 프로세스를 만들기도 한다. 프로그램을 실행시키면 프로세스가 작동한다.
프로세스는 포그라운드 프로세스와 백그라운드 프로세스가 있는데
포그라운드 프로세스는 눈에 보이는 화면 작업이고 
백그라운드 프로세스는 눈에 보이지 않는 곳에서 동작하는 것이다.

멀티 태스킹은 두 가지 이상의 작업을 동시에 처리하는 것이다.
즉 프로세스를 여러 개 사용해서 멀티태스킹 작업을 하는 것이다. 우리가 유튜브를 보면서 카톡을 하고 메모장을 사용하는 것도 멀티태스킹이다.

멀티 태스킹에는 멀티 프로세스와 멀티 스레드가 있다.
멀티 프로세스는 독립적으로 프로그램들을 실행하고 여러 가지 작업을 처리한다.
멀티 스레드는 한 개의 프로그램을 실행하고 내부적으로 여러 가지 작업을 처리한다.

스레드는 작업의 단위를 의미한다.
싱글 스레드는 혼자서 여러 개의 프로세스를 동작시키고
멀티 스레드는 여러 개가 하나의 프로세스를 동작시킨다.
멀티 스레드가 멀티 태스킹이 될 수는 있지만 반대는 불가하다.

기본적으로 자바는 싱글 스레드인데 멀티 스레드 기능도 지원한다.
메인 스레드는 메인 메서드가 시작되면 만들어진다.
메인 스레드가 종료되어도 프로그램은 종료되지 않는다. 모든 스레드가 종료되어야 프로그램이 종료된다.
즉 메인 메서드가 끝나야 메인 스레드가 끝나는 것인데 프로그램은 아직 작동 중인 셈이다.

멀티 스레드를 사용하면 작업의 속도가 느려질 수도 있고 빨라질 수도 있다.
그럼 왜 쓰는가? 하고 묻는다면 동시작업이라는 장점이 매우 크기 때문이다.
멀티 스레드는 보통 게임 개발이나 안드로이드 개발 등에서 자주 쓰인다.

 모든 자바 프로그램은 메인 스레드가 main() 메소드를 실행하며 시작된다.
main() 메소드의 첫 코드부터 아래로 순차적으로 실행된다.
실행 종료 조건은 두 가지가 있는데 첫 번째는 코드가 다 실행되어 마지막 코드를 실행할 때 이고
두 번째는 return문을 만났을 때 이다.

메인 스레드는 작업 스레드들을 만들어 병렬로 코드들을 실행한다. 멀티 스레드를 생성해 멀티 태스킹을 수행하는 것이다.

프로세스가 끝날 때
싱글 스레드는 메인 스레드가 종료하면 프로세스도 종료된다.
멀티 스레드는 실행 중인 스레드가 하나라도 있다면 프로세스가 종료되지 않는다.

메인 스레드 하나를 쓰면 직렬 처리인데 (아래로 쭉 내려감)
메인 스레드를 여러 개 쓰면 따로 따로 실행될 수 있기에 병렬 처리한다.

@ 작업 스레드의 생성과 실행
멀티 스레드로 실행하는 어플리케이션 개발에는 몇 개의 작업을 병렬로 실행할지 결정하는 것이 선행되어야 한다.
즉 프로그램에서 병렬로 실행할 작업을 결정하는 것이다.
메인 스레드에서 메인 작업이 실행되면 스레드 1은 작업 1을 하고 스레드 2는 작업 2를 한다.
예를 들어 메인 스레드에서 프로그램이 시작되면 스레드 1에서 네트워킹 작업을 하고 스레드 2에서는 드로잉 작업을 하는 것이다.

작업 스레드 생성 방법은 두 가지가 있다.
첫째로는 Thread 클래스로부터 Runnable 을 매개값으로 갖는 생성자를 호출해 Thread 클래스로부터 직접 생성하는 방법이 있다.
즉 Runnable 인터페이스를 구현하는 것이다.
둘째는 Thread 클래스를 상속 후 run  메소드를 재정의 해 스레드가 실행할 코드를 작성하는 Thread 하위 클래스로부터 생성하는 방법이다.

@ Runnable 인터페이스가 만들어진 이유
자바는 다중상속을 지원하지 않기 때문이다. 이럴땐 인터페이스를 써서 구현하면 된다.
스레드를 실행할 때 thread.run으로 직접 호출하면 아무것도 실행되지 않는다.
thread.start로 해야 한다.
내가 재정의한건 run 메서드 이지만 strat로 해야 작업이 실행된다.
start는 구현한 내 꺼를 쓴다. 즉 생성자 매개변수로 Runnable을 구현한 것이다. 
Runnable 꺼니까 내꺼를 매개변수로 준 것이다. (오버라이드로 인해)
상속받은 run도 인터페이스의 run도 결국엔 Runnable 인터페이스에서 나온 것이다.

@ 스레드의 이름
스레드에도 이름이 있다.
메인 스레드의 이름은 main 이다.
작업 스레드의 이름은 자동으로 설정된다. thread.getName();
작업 스레드의 이름을 변경하려면 thread.setName("스레드 이름");
코드를 실행하는 현재 스레드 객체의 참조를 얻으려면 Thread thread = Thread.currentThread();

@ 스레드의 우선 순위
- 동시성과 병렬성
동시성이란 멀티 작업을 위해 하나의 코어에서 멀티 스레드가 번갈아가며 실행하는 것이다.
병렬성이란 멀티 작업을 위해 멀티 코어에서 개별 스레드를 동시에 실행하는 것이다.

- 스레드 스케줄링
스레드의 개수가 코어의 수보다 많을 경우에 사용한다.
스레드를 어떤 순서로 동시성으로 실행할 것인가를 결정하는 것이 스레드 스케줄링이다.
스케줄링에 의해 스레드들은 번갈아가며 run() 메소드를 실행한다.
실행 대기 상태인 스레드들이 스케줄링에 의해 순서를 부여받고 번갈아가며 조금씩 CPU(코어)에서 run() 메소드를 실행함.

- 자바의 스레드 스케줄링
우선 순위 방식(Priority)과 순환 할당 방식(Round-Robin)을 사용한다.
 
우선 순위 방식은 코드로 제어가 가능하다.
우선 순위가 높은 스레드가 실행 상태를 더 많이 가지도록 스케줄링한다.
1부터 10까지의 값을 가질 수 있으며 기본값은 5 이다.

순환 할당 방식은 코드로 제어할 수 없다.
시간 할당량(Time Slice)을 정해서 하나의 스레드를 정해진 시간만큼 실행하는 것이다. 

@ 동기화 메소드와 동기화 블록

- 동기화 메소드 및 동기화 블록 (synchronnized)
동기화 메소드 및 동기화 블록은 단 하나의 스레드만 실행할 수 있는 메소드 , 블록이다.
다른 스레드는 메소드나 블록의 실행이 끝날 때까지 대기해야 한다.

- 동기화 메소드 : 
public synchronized void method() {
 임계영역 // 단 하나의 스레드만 실행
} ;

스레드가 

- 동기화 블럭
public void method () {
 임계영역  // 단 하나의 스레드만 실행
 }
 // 여러 스레드가 실행 가능한 영역
}

- 공유 객체를 사용할 때 주의할 점
멀티 스레드가 하나의 객체를 공유해서 생기는 오류가 있다.
스레드 1이 공유 객체의 동기화 메소드, 동기화 블럭, 일반 메소드를 사용하고 있다면
스레드 2는 공유객체의 일반 메소드만 사용 가능하다.
객체 잠금이 일어난 것이다. (?)

@ 스레드 상태

- 스레드의 일반적인 상태
스레드는 NEW 객체를 생성하고 start()로 실행한다. 실행 대기 중이던 RUNNABLE 인터페이스는 실행과 대기를 반복한다. 그리고 마침내 모든 코드블럭이 종료되면 TERMINATED 된다.

- 스레드가 일시 정지 상태에 도입한 경우
실행 대기 중이던 RUNNABLE이 실행을 하고 일시 정지 상태에 도입하면 일시 정지 되었다가 다시 실행 대기 상태로 변환된다.

스레드의 상태 - 열거 상수 - 설명

객체 생성 - NEW - 스레드 객체가 생성, 아직 start() 메소드가 호출되지 않은 상태
실행 대기 - RUNNABLE - 실행 상태로 언제든지 갈 수 있는 상태
일시 정지 - BLOCKED - 사용하고자 하는 객체의 락이 풀릴 때까지 기다리는 상태
일시 정지 - WAITING - 다른 스레드가 통지할 때까지 기다리는 상태
일시 정지 - TIMED_WAITING - 주어진 시간동안 기다리는 상태
종료 - TERMINATED - 실행을 마친 상태

@ 스레드 상태 제어

- 상태 제어
실행 중인 스레드의 상태를 변경하는 것

- 상태 변화를 가져오는 메소드의 종류 
일시정지에서 실행 대기로: interrupt(), notify(), notifyAll()
실행에서 실행대기로: yield()
실행에서 일시 정지로: sleep(), join(), wait()

- sleep() : 주어진 시간 동안 일시 정지 
try { Thread.sleep(1000);
 } catch(InterruptedException e ) {
 // interrupt() 메소드가 호출되면 실행
}
  얼마나 일시 정지 상태로 있을 것인지 밀리 세컨드 단위로 지정한다.
  일시 정지 상태에서 interrupt() 메소드를 호출한다. InterruptedExceptiron 발생 (예외 발생)

- yield() : 다른 스레드에게 실행을 양보
예를 들어 무의미한 반복을 하는 스레드일 경우 동일 또는 높은 우선 순위를 가진 스레드에게 양보한다.

- join() : 다른 스레드의 종료를 기다림
ThreadA - threadB.start(); threadB.join(); // 일시 정지 >> ThreadB - run(){} >> ThreadB 코드 블럭 종료 >> ThreadA로 돌아옴
계산 작업을 하는 스레드가 모든 계산 작업을 마치고 결과값을 받아 이용하는 경우에 주로 사용한다.

- wait(), notify(), notifyAll() : 스레드간 협업
 동기화 메소드 또는 동기화 블록에서만 호출 가능한 Object의 메소드
실행 대기중인 RUNNABLE이 스레드를 실행할 때 notify(), notifyAll() 은 협업을 통해 일시정지 상태로 만들어준다.
일시 정지 상태인 Waiting Pool 스레드에서는 wait() 작동한다. 그리고 다시 실행 대기 상태로 바뀐다.
 두 개의 스레드가 교대로 번갈아 가며 실행해야 할 경우 주로 사용한다.
공유객체에 데이터가 들어있고 생산자 스레드와 소비자 스레드가 있을 때
생산자 스레드는 데이터를 저장하고 소비자 스레드는 데이터를 읽는다.
데이터를 저장하고 읽을 때 wait() 메소드를 사용한다.
생산자 스레드에서 소비자 스레드로 갈 때 notify() 메소드가 이용된다.

@ stop 플래그, interrupt() : 스레드의 안전한 종료
 경우에 따라 실행 중인 스레드를 즉시 종료해야 할 필요가 있을 때 사용한다.
 stop() 메소드 사용 시 스레드가 즉시 종료되는 편리함이 있다.
 그러나 사용 중이던 자원들이 불안전한 상태로 남겨진다 (Deprecated)

- stop 플래그를 이용하는 방법 : stop 플래그로 메소드의 정상 종료를 유도한다.
private boolean stop; // stop 플래그 필드
public void run() { while(!stop) { // stop 이 true가 되면 run() 메소드는 종료된다. } } }

- interrupt()  메소드를 이용하는 방법
스레드가 일시 정지 상태일 경우 InterruptedException을 발생 시킨다.
실행대기 또는 실행상태에서는 InterruptedException이 발생하지 않는다.
일시 정지 상태로 만들지 않고 while문 빠져나오는 방법으로도 쓰인다.


